// SPDX-License-Identifier: BUSL-1.1
// This file is generated. Please do not edit this file manually.
//   yarn ts-node scripts/GenTickMath.ts
pragma solidity ^0.8.28;

// slither-disable-start too-many-digits
// slither-disable-start cyclomatic-complexity

/* solhint-disable*/
// prettier-ignore
library TickMath {
    /// @return rate = g(tick * step)
    /// @param step must be less than 16
    /// @notice g(tick) = 1.00005^tick - 1 for tick >= 0
    /// @notice g(tick) = -g(-tick) for tick < 0
    function getRateAtTick(int16 tick, uint8 step) internal pure returns (int128 rate) {
        unchecked {
            return _getRateAtTick(int24(tick) * int24(uint24(step)));
        }
    }

    /// @return rate = g(tick)
    /// @notice g(tick) = 1.00005^tick - 1 for tick >= 0
    /// @notice g(tick) = -g(-tick) for tick < 0
    /// @dev This function only works for tick from -32768 * 15 to 32767 * 15
    /// The algorithm is divided into 2 parts:
    /// - The first part is similar to https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/TickMath.sol#L23
    ///   That is, we calculate the inverse (1/1.00005^tick) for better precision.
    /// - When tick has become too big, the inverse calculation will lose precision.
    ///   So for the second part, we convert it back to (1.00005^tick) then continue the calculation.
    function _getRateAtTick(int24 tick) private pure returns (int128 rate) {
        unchecked {
            if (tick == 0) return 0;
            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));

            uint256 _rate;
            _rate = absTick & 0x1 != 0
                ? 0xfffcb92e5f40b9f2f86266c763702fb7
                : 0x100000000000000000000000000000000;
            if (absTick & 0x2 != 0) _rate = (_rate * 0xfff972677b0287f20ca2232ae174ac61) >> 128;
            if (absTick & 0x4 != 0) _rate = (_rate * 0xfff2e4f9e77ca923223ffc276878b031) >> 128;
            if (absTick & 0x8 != 0) _rate = (_rate * 0xffe5ca9f907218edf3c20a9b87d8b905) >> 128;
            if (absTick & 0x10 != 0) _rate = (_rate * 0xffcb97ee039bed3373e5b571bf3e4989) >> 128;
            if (absTick & 0x20 != 0) _rate = (_rate * 0xff973a9678d50163584a32b3255afbbc) >> 128;
            if (absTick & 0x40 != 0) _rate = (_rate * 0xff2ea00defa36b3de45cff7e3bc651f2) >> 128;
            if (absTick & 0x80 != 0) _rate = (_rate * 0xfe5deb59ac7b1aae542822b60b658f66) >> 128;
            if (absTick & 0x100 != 0) _rate = (_rate * 0xfcbe817ac9c95c76b6730ccf91e6d8de) >> 128;
            if (absTick & 0x200 != 0) _rate = (_rate * 0xf9879cae3104ef30d992ea9a423d2979) >> 128;
            if (absTick & 0x400 != 0) _rate = (_rate * 0xf33916a17af80ec5fc60d88f617d0b95) >> 128;
            if (absTick & 0x800 != 0) _rate = (_rate * 0xe7156db1a55bd580fae8391a0ef5618b) >> 128;
            if (absTick & 0x1000 != 0) _rate = (_rate * 0xd097adc1c6919e761394d554da360e46) >> 128;
            if (absTick & 0x2000 != 0) _rate = (_rate * 0xa9f6d43953345a56a0df0cb1c591fb10) >> 128;
            if (absTick & 0x4000 != 0) _rate = (_rate * 0x70d7d2303df60688dcde5dbd2c3f8bb3) >> 128;
            if (absTick & 0x8000 != 0) _rate = (_rate * 0x31bd8ddcefd287b5a91fb8c4681a9810) >> 128;

            _rate = type(uint256).max / _rate; // _rate = 1 / _rate
            _rate >>= 23; // convert from exp 2^128 to 2^105

            if (absTick & 0x40000 != 0) _rate = (_rate * 0xf06345295e343b7bc86046165c00aba) >> 105;
            if (absTick & 0x20000 != 0) _rate = (_rate * 0x57b4d53300bbb68ed922df63e3590) >> 105;
            if (absTick & 0x10000 != 0) _rate = (_rate * 0x34fa3662ba5cbd83623db239c427) >> 105;

            _rate = (_rate * 1e18 + (1 << 104)) >> 105; // convert from exp 2^105 to 10^18
            _rate -= 1e18;
            rate = int128(int256(_rate));
            if (tick < 0) rate = -rate;
        }
    }
}
// slither-disable-end cyclomatic-complexity
// slither-disable-end too-many-digits
